{"version":3,"sources":["app/shared/logger/logger.service.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,sCAA2C;AAe3C,IAAa,aAAa;IA8BtB;;OAEG;IACH;QACI,IAAI,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC;IACnC,CAAC;IAlCM,8BAAM,GAAb;QAAc,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACxB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,MAAM,OAAd,OAAO,EAAW,IAAI,EAAE;QAAC,CAAC;IAC/D,CAAC;IACM,6BAAK,GAAZ;QAAa,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACvB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,KAAK,OAAb,OAAO,EAAU,IAAI,EAAE;QAAC,CAAC;IAC7D,CAAC;IACM,6BAAK,GAAZ;QAAa,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACvB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,KAAK,OAAb,OAAO,EAAU,IAAI,EAAE;QAAC,CAAC;IAC7D,CAAC;IACM,gCAAQ,GAAf;QAAgB,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAC1B,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,QAAQ,OAAhB,OAAO,EAAa,IAAI,EAAE;QAAC,CAAC;IACnE,CAAC;IACM,4BAAI,GAAX;QAAY,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACtB;;;;;WAKG;QACH,sCAAsC;QACtC,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,IAAI,OAAZ,OAAO,EAAS,IAAI,EAAE;QAAC,CAAC;IAC3D,CAAC;IACM,2BAAG,GAAV;QAAW,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACrB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,GAAG,OAAX,OAAO,EAAQ,IAAI,EAAE;QAAC,CAAC;IACzD,CAAC;IACM,4BAAI,GAAX;QAAY,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QACtB,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAAC,OAAO,CAAC,IAAI,OAAZ,OAAO,EAAS,IAAI,EAAE;QAAC,CAAC;IAC3D,CAAC;IAQL,oBAAC;AAAD,CApCA,AAoCC,IAAA;AApCY,aAAa;IADzB,iBAAU,EAAE;;GACA,aAAa,CAoCzB;AApCY,sCAAa;AAuC1B;;;;;GAKG;AACU,QAAA,gBAAgB,GAAU;IACnC,EAAE,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,aAAa,EAAE;CACtD,CAAC","file":"logger.service.js","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\nexport interface ILogger {\r\n    assert(...args: any[]): void;\r\n    error(...args: any[]): void;\r\n    group(...args: any[]): void;\r\n    groupEnd(...args: any[]): void;\r\n    info(...args: any[]): void;\r\n    log(...args: any[]): void;\r\n    warn(...args: any[]): void;\r\n}\r\n\r\ndeclare var console: any;\r\n\r\n@Injectable()\r\nexport class LoggerService implements ILogger {\r\n    public assert(...args: any[]): void {\r\n        if (console && console.assert) { console.assert(...args); }\r\n    }\r\n    public error(...args: any[]): void {\r\n        if (console && console.error) { console.error(...args); }\r\n    }\r\n    public group(...args: any[]): void {\r\n        if (console && console.group) { console.group(...args); }\r\n    }\r\n    public groupEnd(...args: any[]): void {\r\n        if (console && console.groupEnd) { console.groupEnd(...args); }\r\n    }\r\n    public info(...args: any[]): void {\r\n        /* INFO: I know this is definitely going against our tslint rules.\r\n         * Since that essentially says that we shouldn't use console writing\r\n         * methods in production code of course. We have to find a way so we\r\n         * can turn proper logging level on and off in development and production\r\n         * mode so It's easier to debug when we want to and log in both modes.\r\n         */\r\n        // tslint:disable-next-line:no-console\r\n        if (console && console.info) { console.info(...args); }\r\n    }\r\n    public log(...args: any[]): void {\r\n        if (console && console.log) { console.log(...args); }\r\n    }\r\n    public warn(...args: any[]): void {\r\n        if (console && console.warn) { console.warn(...args); }\r\n    }\r\n\r\n    /**\r\n     * Generic logger service for console\r\n     */\r\n    constructor() {\r\n        this.log('Logger Initialized');\r\n    }\r\n}\r\n\r\n\r\n/* INFO:\r\n * We will definitely need a default implementation of the ILogger if we\r\n * ever decide we will go for a platform specific logger implementation.\r\n *\r\n * But as per YAGNI, this will do now.\r\n */\r\nexport const LOGGER_PROVIDERS: any[] = [\r\n    { provide: LoggerService, useClass: LoggerService }\r\n];\r\n"]}